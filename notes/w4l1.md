# Week Four, Lecture One
## Pumping Lemma Proofs ğŸš²ğŸ’¨
You **can**:
- select any string s âˆˆ L where |s| >= p
- accidentally choose some *s* which DOES satisfy the pumping lemma and CAN be pumped to any length

You **cannot**:
- assume the partition of *xyz* e.g. "let x = ..." or "let xy = ..."
- assume that some "{w | w=rst}" means x=r, y=s, z=t
    - x,y,z can be ANY possible assignment
    - you have to show that NO possible assignment works

## Chomsky Hierarchy Proofs
Remember that the following models are all equivalent:
<div align="center">
DFA â‰£ NFA â‰£ GNFA â‰£ RegEx
</div>

- It is rather trivial that a DFA is equivalent to an NFA, as a DFA is just a specific, particularly strict *type* of NFA
- It is also intuitive that an NFA is equivalent to a GNFA, as a GNFA is a *generalized* NFA

However, the following proofs are less obvious and we'll be going over (within a week at least):
1. NFA â‰£ DFA
2. RegEx â‰£ NFA i.e. grep is taking a pattern (RegEx) and going to an executable program (specifically RegEx â†’ NFA â†’ DFA)
3. GNFA â‰£ RegEx

Note that **all** these proofs are *constructive* proofs i.e. we will be proving you can construct one from the other.

## RegEx â‰£ GNFA
Take your initial state in your GNFA and your accepting state. Since GNFAs allow more than one matched symbol per transition, we can literally just put the RegEx *R* on that one label from q<sub>0</sub> to q<sub>A</sub>.

## NFA â‰£ DFA
You are given an NFA *N* := (Q, Î£, Î´, q<sub>0</sub>, F) and the language that is accepted by N is â„’(N). Your task is to show that there is some DFA *M* (remember that these are all constructive proofs!) such that â„’(M) = â„’(N) i.e. N and M accept the same language.

<div align="center">
Write. It. Down.<br>
ğŸ“. ğŸ¤¡. â¬‡ï¸!
</div>

M := (ğ’«(Q), Î£, Î´', ?, F').

Every possible state that N could ever go through for some string w in â„’(N) is denoted as Î´<sup>\*</sup>(q<sub>0</sub>, w) = R i.e. given some string in â„’(N), our machine N must accept that string. (R âŠ† F).

We write M's transition function Î´' as Î´' :: (ğ’«(Q)Ã—Î£) â†’ ğ’«(Q) (i.e. the domain is (ğ’«(Q)Ã—Î£) (all possible states of N and all symbols in the alphabet); the range is ğ’«(Q) i.e. some other set of states of N).

We apply Î´' to each state V âˆˆ ğ’«(Q) (each possible set of states of N) and to each symbol *a* âˆˆ Î£:

<div align="center">
Î´'(V, a) = {q âˆˆ Q | q âˆˆ Î´<sup>\*</sup>(v, a), v âˆˆ V}
</div>

The above says: Consider every state *v* of V. For each v, we compute the set of states that N could go to *from* that state, given the current symbol *a*.

```python
# delta_prime is a map from (Set, Char) -> Set

for each V in PowerSet(N.Q):
    for each a in Sigma:
        for each v in V:
            for q in N.Q:
                if q in star(N.delta(v,a)):
                    M.delta[V][a] += q
```

